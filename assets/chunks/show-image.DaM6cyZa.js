import{_ as g}from"./tslib.es6.kHcLnhpD.js";import{i as k,l as A,x as m,m as _,h as I}from"./chain-of-custody-client.BqnHCiTp.js";import{a as R,c as S,t as b,s as C}from"./property.Dcn1XGnH.js";import{h as x,l as E}from"./context.CzT3nprN.js";import"./profile-list-item.a954bdWc.js";import{a as P}from"./reactive-element.ChgaCBqn.js";import{f as $}from"./chunk.7E4JTYWU.Lt4ja_ED.js";/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const j=Symbol();class G{constructor(t,e,i){this.i=0,this.status=0,this.autoRun=!0,this.t=t,this.t.addController(this);const r=typeof e=="object"?e:{task:e,args:i};this.o=r.task,this.h=r.args,this.l=r.onComplete,this.u=r.onError,r.autoRun!==void 0&&(this.autoRun=r.autoRun)}get taskComplete(){return this.v||(this.status===1?this.v=new Promise((t,e)=>{this.m=t,this._=e}):this.status===3?this.v=Promise.reject(this.k):this.v=Promise.resolve(this.p)),this.v}hostUpdated(){this.performTask()}async performTask(){var t;const e=(t=this.h)===null||t===void 0?void 0:t.call(this);this.shouldRun(e)&&await this.run(e)}shouldRun(t){return this.autoRun&&this.T(t)}async run(t){var e,i,r,a,n;let l,h;t!=null||(t=(e=this.h)===null||e===void 0?void 0:e.call(this)),this.status!==1&&(this.v=void 0,this.m=void 0,this._=void 0),this.status=1,queueMicrotask(()=>this.t.requestUpdate());const y=++this.i;try{l=await this.o(t)}catch(w){h=w}if(this.i===y){if(l===j)this.status=0;else{if(h===void 0){try{(i=this.l)===null||i===void 0||i.call(this,l)}catch{}this.status=2,(r=this.m)===null||r===void 0||r.call(this,l)}else{try{(a=this.u)===null||a===void 0||a.call(this,h)}catch{}this.status=3,(n=this._)===null||n===void 0||n.call(this,h)}this.p=l,this.k=h}this.t.requestUpdate()}}get value(){return this.p}get error(){return this.k}render(t){var e,i,r,a;switch(this.status){case 0:return(e=t.initial)===null||e===void 0?void 0:e.call(t);case 1:return(i=t.pending)===null||i===void 0?void 0:i.call(t);case 2:return(r=t.complete)===null||r===void 0?void 0:r.call(t,this.value);case 3:return(a=t.error)===null||a===void 0?void 0:a.call(t,this.error);default:this.status}}T(t){const e=this.g;return this.g=t,Array.isArray(t)&&Array.isArray(e)?t.length===e.length&&t.some((i,r)=>P(i,e[r])):t!==e}}function o(s){return new Promise((t,e)=>{s.oncomplete=s.onsuccess=()=>t(s.result),s.onabort=s.onerror=()=>e(s.error)})}function p(s,t){const e=indexedDB.open(s);e.onupgradeneeded=()=>e.result.createObjectStore(t);const i=o(e);return(r,a)=>i.then(n=>a(n.transaction(t,r).objectStore(t)))}let f;function d(){return f||(f=p("keyval-store","keyval")),f}function M(s,t=d()){return t("readonly",e=>o(e.get(s)))}function T(s,t,e=d()){return e("readwrite",i=>(i.put(t,s),o(i.transaction)))}function U(s,t=d()){return t("readwrite",e=>(e.delete(s),o(e.transaction)))}function O(s,t){return s.openCursor().onsuccess=function(){this.result&&(t(this.result),this.result.continue())},o(s.transaction)}function B(s=d()){return s("readonly",t=>{if(t.getAll&&t.getAllKeys)return Promise.all([o(t.getAllKeys()),o(t.getAll())]).then(([i,r])=>i.map((a,n)=>[a,r[n]]));const e=[];return s("readonly",i=>O(i,r=>e.push([r.key,r.value])).then(()=>e))})}const u=p("HC_ZOME_FILE_STORAGE","IMAGES");async function v(s,t){await T(s,{image:t,lastRead:Date.now()},u),K()}async function D(s){const t=await M(s,u);if(t)return v(s,t.image),t.image}const F=7*24*60*60*1e3;async function K(){const s=await B(u);for(const[t,e]of s)Date.now()-e.lastRead>F&&await U(t,u)}let c=class extends k{constructor(){super(...arguments),this._renderImage=new G(this,async([t])=>{const e=await D(t);if(e)return e;const i=await this.client.downloadFile(t),r=await i.arrayBuffer(),a=`data:${i.type};base64,${A(new Uint8Array(r))}`;return v(t,a),a},()=>[this.imageHash])}renderImage(t){return m`<div style="flex:1"><img src="${t}" part="image" style="object-fit: cover; overflow: hidden; width: 100%; height: 100%"></img></div>`}render(){return this._renderImage.render({complete:t=>this.renderImage(t),pending:()=>m`<sl-skeleton
          style="flex: 1; --border-radius: 0"
          effect="pulse"
        ></sl-skeleton> `,error:t=>m`<display-error
          .headline=${_("Error fetching the image")}
          .error=${t}
        ></display-error>`})}static get styles(){return[C,I`
        :host {
          display: flex;
        }
      `]}};g([R(x("image-hash"))],c.prototype,"imageHash",void 0);g([S({context:$})],c.prototype,"client",void 0);c=g([E(),b("show-image")],c);
